---
title: Path to Success
nav_order: 60
---

# How to solve an impossible problem

We need to remember that our capability is not fixed, but that we can learn as we solve a problem.

To solve a problem, we need to create a hook to begin working on it. This means finding a spot we can start iterating from, where we will receive a strong signal if this path is viable or not.

A critical part of having a signal is the system must work as a whole from the start, even if some pieces are faked.

We need to examine our presuppositions of how we are approaching a problem; to find new approaches that are easier to know if we’re on a viable path or a dead end.

By iteratively improving our implicit knowledge structure over time, we can eventually become capable of solving an impossible problem.

(Impossible problem)[impossible_problem.JPG]

# Iteration time

A fast iteration time is important.

Simplicity is important because speed of executionl or perhaps more importantly, time, is a critical factor when solving a problem.

> I am become death (time), the destroyer of worlds."

The environment changes with time, so it is harder, or even impossible to hit a moving target.

Simplicity directly results in a faster *reaction speed*, which allows maneuver in a dynamic situation.

> Reflexes are faster than musicales since they are simpler.

Especially in a complex competitive situation between humans, faster reaction and maneuver can result in complete victory, not just an incremental advantage. However even incremental advantage quickly snowballs to overwhelming victory with the Pareto Principle.

> Pareto Principle - The rich get richer and the poor get poorer.

Simple reduces the iteration time of your hook into something that is real. This allows you to pick up a signal more clearly, as you measure after each iteration step.

	  observe
	    ->
	me       reality
	    <-
	  feedback (signal)
  
	Iteration loop
	
	
	

# Notes

# How to solve an impossible problem

1. The hook
2. Start with simple
3. Has to work at every step of the process since what gives you your signal
4. Use signal to iterate towards goal
5. Learn from simple as doing
6. Path changes as doing
7. Has to be fun

## Hook
The *hook* is what you create that lets you pick up a *signal* to start *step*ping towards a *target*.

## Signal (feedback loop)
Has to be working from start to end at every step of the process, even if some parts are ‘faked’, since that’s what gives you your signal. If the problem you are solving becomes so opaque that there is no clear way forward, you need to take a step back and modify your implicit representation of the problem - to have a clear stepable way forward with a quick and strong signal (feedback loop).
>> Have to be receiving a clear signal of which direction to go at every step. If the problem you are solving becomes so opaque that it is not clear what to do to move forward, you need to change your approach to a way that allows you to see what is broken clearly.

Aim at the target, but move towards the signal. The signal is reality telling you what works and what doesn’t.

The target is where we are trying to get to in our own representation of the world.

Create implicit structure, and iterate and build upon it over time. How to create ‘culture’ over time, that is effective and gets better little by little. 

## Simple
## Iterate (step)
## Fun


1. Path to success 


# Path to Success

Iterated path towards success, starting with something simple.

Allows you to develop skill and expertise in area as you are doing it.

Can 'debug' and discover path to move forward as doing.

> The product must be viable at every stage

### In practice

This is how we approaching a game engine to Android. We initially tried to port the rendering as one large blob. This was almost impossible, as it was extremely difficult to tell what was broken, and where bugs were coming from.

However, we took a step back and tried a new approach. We starting with rendering a simple triangle on device, the simplest version of what we needed to do. This created a path by which we could move towards success. We then added bits on to this, piece by piece, but at every stage having a working version. 

Many of the pieces were 'faked' to start. This allows the necessary construction of the macro structure, as well as it's iteration. 